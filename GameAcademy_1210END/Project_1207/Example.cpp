#include "Example.h"

namespace EXAMPLE_0 {
	/*
	- 전처리기 -
	- 실행 파일을 생성하는 과정에서 컴파일 하기 직전, 소스파일 내에 존재하는 
	선행 처리 지시문을 처리하는 작업을 의미한다.

	-전처리가 실행되면 각 코드 파일에서 지시자를 찾는다.
		-> 지시자는 #으로 시작해서 줄 바꿈으로 끝나는 코드 

	선행 처리를 위한 명령에는 맨 앞에 # 기호가 붙는다는 공통점이 있다.


	전처리기 -> 컴파일러 -> 어셈블러 -> 링커 

	-전처리기 
	헤더 파일 삽입, 코드의 주석제거, 문법 검토, 매크로 등을 치환하는 기능을 한다.

	컴파일러:
	어셈블리 파일로 변환을 한다.

	어셈블러 : // 어셈블러까지 프로그래머가 확인가능하다 
	어셈블리 코드를 기계어 (0 or 1)로 변환하여 오브젝트 파일을 생성한다.

	링커:
	각각의 오브젝트 파일들을 묶어서 실행 코드 파일로 변환한다.(링크)


	** 소스코드 -> 바이너리(이진법) -> 실행파일

	=================================================================

	선행처리를 위한 명령 = 전처리 문 = 전처리기 연산자 

	-파일 처리를 위한 전처리문 : #include
		->#include<파일이름>		미리 정의된 include 폴더에서 파일을 찾는다.
		->#include "파일이름.h"		현재의 소스코드가 정의되어 있는 폴더에서 먼저 찾고,
									파일이 없다면 미리 정의된 include폴더에서 찾는다.

	-형태 정의를 위한 전처리 문 : #define , #undef
	-> #define 키워드는 매크로 상수 또는 매크로 함수를 정의하는 역할을 한다.

	-조건부 컴파일을 위한 전처리문 : #if, #ifdef, #ifndef, #else, #elif, #endif

	#undef : 식별자를 정의하지 않는다.(정의된 매크로 삭제)
	#ifdef : 식별자가 참이면 동작(식별자가 정의되어 있으면 참)
	#ifndef : 식별자가 정의 되어 있지 않으면 참
	#endif : if, #ifdef, #else, #elif 에 대한 전처리기 부분을 종료

	//컴파일러에게 선택적 코드 할당
	//쓰면 실행속도가 압도적으로 빨라진다. (쓸모없는 코드를 안쓰니까)
	#if 조건A
	codeA

	#elif 조건B
	codeB

	#else
	codeC

	#endif //끝을 알려준다.

	=================================================================

	pragma : 컴파일러의 기능을 확장시킬 수 있게 나온 문법이며 어떤 동작을 정해주기 위해 사용한다.
	주의점 : 사용 중인 컴파일러의 버전 or OS(운영체제)에 따라 동작하지 않을 수 도 있다.

	윈도우 <=> 리눅스

	#pragma once : 링커가 링크를 할때 헤더 파일이 한번만 포함되게 한다.

	#pragma region 이름
	- 내용
	#pragma endregion 설명

	#pragma message("");
	- 컴파일시 출력창에 메세지 출력 (주로 협업시 개발자에게 알려줄 때 사용한다.) 왠만하면 쓰지말 것
		 ㄴ assert(score >= 0); 차라리 어설트를 사용 >> 조건이 안맞을 때 assert error를 발생시킨다.





	*/

	#pragma message("프라그마 메세지 ");

	#pragma region MyRegion

	/*
		매크로 상수를 정의 할때 주의점 
		1. #define 문은 코드를 생성하는 명령이 아니며 매크로 이름도 일종의 명칭이기 때문에 
		명칭 규칙에 맞게 작성해야 한다. 

		2. 매크로 이름에는 공백이 들어갈 수 없지만 매크로의 실제 값은 공백값을 가질 수 있다.

		3.문자열 상수내에 있는 매크로나 다른 명칭의 일부로 포함된 경우는 치환되지 않는다.

		4.매크로는 중첩가능
			ex) #define A 3
			ex) #define B (A * 3)

		5. 값을 가지지 않는 빈 매크로 역시 정의가 가능하다.
			ex) #define AAA
				ㄴ상수 자체만 존재 

		**매크로 상수는 컴파일러 입장에서 리터널 상수와 동일시 한다.
			-> 컴파일러는 매크로 상수의 존재를 알지 못한다.

	*/

	#pragma endregion 매크로 상수 주의점


	//매크로 정의
	//매크로는 세미콜론을 붙이지 않는다.
	//#define 매크로명 실제값
	#define EXAMPLE_1	1
	#define EXAMPLE_2	1

	#undef EXAMPLE_2

	#define EXAMPLE_2	2
	//매크로도 특성을 알면 함수처럼 동작을 시키는 것이 가능하다.(엄밀히 함수 X)
	#define	 ADD(a)		((a)*(a)) //매크로 예시

	

	//전처리기 수업 1207
	void PreprocessorClass_1207()
	{
		cout << ADD(5) << endl;	
		GetMultipleValue(5);


		//mainGame* mg;	//포인터 클래스 선언?
		//mg->~mainGame(); // 소멸자 호출

	}

	void GetMultipleValue(int numA)
	{
		cout << numA * numA << endl;
	}
}